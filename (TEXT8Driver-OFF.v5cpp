void driveStraightFor(double travelDist) {
    double deadzone = 0.95; // Deadzone value between 0 and 1
    double kP = 0.1; // Adjust later, changes degrees of error to a decimal
    double mod = 2; // Adjust later, keeps drivetrain at a reasonable speed
    double minMotorSpeed = 20.0; // Minimum motor speed
    double maxMotorSpeed = 100.0; // Maximum motor speed
    DrivetrainInertial.setHeading(90, degrees); // Prevents rolling over to 359
    double currentVelocity = Drivetrain.velocity(percent);
    Drivetrain.driveFor(travelDist, inches, false);
    
    while (!Drivetrain.isDone()) {
        // Calculate remaining distance
        double remainingDistance = travelDist - Drivetrain.distance(inches);
        
        // Adjust motor speed based on remaining distance
        double motorSpeed = maxMotorSpeed * (remainingDistance / travelDist);
        if (motorSpeed < minMotorSpeed) {
            motorSpeed = minMotorSpeed;
        } else if (motorSpeed > maxMotorSpeed) {
            motorSpeed = maxMotorSpeed;
        }
        
        // Adjust motor speeds based on heading error
        if (DrivetrainInertial.heading(degrees) > (90 * deadzone)) {
            double drivetrainLeftSideSpeed = (((DrivetrainInertial.heading(degrees) - 90) * kP) * mod);
            LeftDriveSmart.setVelocity(drivetrainLeftSideSpeed, percent);
        } else if (DrivetrainInertial.heading(degrees) < (90 * deadzone)) {
            double drivetrainRightSideSpeed = (((90 - DrivetrainInertial.heading(degrees)) * kP) * mod);
            RightDriveSmart.setVelocity(drivetrainRightSideSpeed, percent);
        } else {
            LeftDriveSmart.setVelocity(motorSpeed, percent);
            RightDriveSmart.setVelocity(motorSpeed, percent);
        }
        
        // Output motor speeds for debugging
        std::cout << "Left Speed: " << LeftDriveSmart.velocity(percent) << std::endl;
        std::cout << "Right Speed: " << RightDriveSmart.velocity(percent) << std::endl;
        
        this_thread::sleep_for(10);
    }
}