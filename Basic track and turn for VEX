// by Gllitchh
void turnToTarget() {
  double kP = 0.100;  // Proportional gain
  double minMotorSpeed = 5.0;
  int deadzone = 2;  // Dead zone to stop the robot when close to the target
  int VISION_FOV_WIDTH = 316;  // Width of the Vision Sensor's field of view in pixels

  while (true) {
    Vision1.takeSnapshot(Vision1__SIG_1);

    if (Vision1.objectCount > 0) {
      // Get the largest detected object
      vision::object targetObject = Vision1.largestObject;

      // Calculate the error based on the object's position relative to the center of the field of view
      double error = targetObject.centerX - (VISION_FOV_WIDTH / 2);

      // Ensure error is within the range [-VISION_FOV_WIDTH/2, VISION_FOV_WIDTH/2]
      if (error < -VISION_FOV_WIDTH / 2) {
        error += VISION_FOV_WIDTH;
      } else if (error >= VISION_FOV_WIDTH / 2) {
        error -= VISION_FOV_WIDTH;
      }

      // Apply dead zone
      if (fabs(error) < deadzone) {
        Drivetrain.stop();
        break;
      }

      // Calculate motor speed based on error
      double motorSpeed = error * kP;

      // Ensure the motor speed is above the minimum threshold
      if (fabs(motorSpeed) < minMotorSpeed) {
        motorSpeed = copysign(minMotorSpeed, motorSpeed);
      }

      // Set the motor speeds for turning
      LeftDriveSmart.setVelocity(motorSpeed, percent);
      RightDriveSmart.setVelocity(-motorSpeed, percent);

      // Spin the motors
      LeftDriveSmart.spin(forward);
      RightDriveSmart.spin(forward);
    } else {
      // No target detected, stop the drivetrain
      Drivetrain.stop();
    }

    wait(20, msec);
  }
}
