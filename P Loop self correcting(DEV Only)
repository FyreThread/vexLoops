//PID Loop. Dev only. Kind of works

// Constants for PID control
double kP = 0.4; // Proportional gain
double kI = 0.01; // Integral gain
double kD = 0.2; // Derivative gain
double integral = 0.0; // Integral term
double lastError = 0.0; // Last error for derivative term

// Limits for the integral term to prevent integral windup
double integralLimit = 100.0; // Adjust as needed
double integralThreshold = 5.0; // Threshold to activate integral control

// Turn left with PID control
void turnLeftDegrees(double targetDegrees) {
  // Calculate target heading
  double targetHeading = Drivetrain.heading() - targetDegrees;

  // Ensure targetHeading is within the range [0, 360)
  if (targetHeading < 0) {
    targetHeading += 360.0;
  } else if (targetHeading >= 360.0) {
    targetHeading -= 360.0;
  }

  // Initialize variables
  double error;
  double motorSpeed;

  // Turn left until the target heading is reached
  while (true) {
    // Calculate error
    double currentHeading = Drivetrain.heading();
    error = targetHeading - currentHeading;
    
    // Ensure error is within the range [-180, 180)
    if (error < -180.0) {
      error += 360.0;
    } else if (error >= 180.0) {
      error -= 360.0;
    }

    // Update integral term (with anti-windup)
    if (fabs(error) < integralThreshold) {
      integral += error;
      // Limit integral term to prevent integral windup
      integral = vex::clamp(integral, -integralLimit, integralLimit);
    } else {
      integral = 0.0;
    }

    // Calculate derivative term
    double derivative = error - lastError;
    lastError = error;

    // Calculate motor speed using PID control
    motorSpeed = kP * error + kI * integral + kD * derivative;

    // Set motor speeds for left turn
    LeftDriveSmart.setVelocity(motorSpeed, percent);
    RightDriveSmart.setVelocity(-motorSpeed, percent); // Reverse the direction

    // Spin the motors for left turn
    LeftDriveSmart.spin(forward);
    RightDriveSmart.spin(forward);

    // Break the loop if the error is small enough
    if (fabs(error) < 2.0) {
      Drivetrain.setDriveVelocity(150.0, percent);
      Drivetrain.stop();
      break;
    }
    
    // Wait for a short duration
    wait(5, msec);
  }

  // Stop the drivetrain
  Drivetrain.stop();
}

// Turn right with PID control
void turnRightDegrees(double targetDegrees) {
  // Calculate target heading
  double targetHeading = Drivetrain.heading() + targetDegrees;

  // Ensure targetHeading is within the range [0, 360)
  if (targetHeading < 0) {
    targetHeading += 360.0;
  } else if (targetHeading >= 360.0) {
    targetHeading -= 360.0;
  }

  // Initialize variables
  double error;
  double motorSpeed;

  // Turn right until the target heading is reached
  while (true) {
    // Calculate error
    double currentHeading = Drivetrain.heading();
    error = targetHeading - currentHeading;
    
    // Ensure error is within the range [-180, 180)
    if (error < -180.0) {
      error += 360.0;
    } else if (error >= 180.0) {
      error -= 360.0;
    }

    // Update integral term (with anti-windup)
    if (fabs(error) < integralThreshold) {
      integral += error;
      // Limit integral term to prevent integral windup
      integral = vex::clamp(integral, -integralLimit, integralLimit);
    } else {
      integral = 0.0;
    }

    // Calculate derivative term
    double derivative = error - lastError;
    lastError = error;

    // Calculate motor speed using PID control
    motorSpeed = kP * error + kI * integral + kD * derivative;

    // Set motor speeds for right turn
    LeftDriveSmart.setVelocity(motorSpeed, percent);
    RightDriveSmart.setVelocity(-motorSpeed, percent); // Reverse the direction

    // Spin the motors for right turn
    LeftDriveSmart.spin(forward);
    RightDriveSmart.spin(forward);

    // Break the loop if the error is small enough
    if (fabs(error) < 2.0) {
      Drivetrain.stop();
      Drivetrain.setDriveVelocity(150.0, percent);
      break;
    }
    
    // Wait for a short duration
    wait(5, msec);
  }

  // Stop the drivetrain
  Drivetrain.stop();
}
