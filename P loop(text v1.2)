void turnLeftDegrees(double targetDegrees) {
  // Proportional gain (adjust as needed)
  double kP = 0.43; // Adjust as needed

  // Dead zone for the controller (adjust as needed)
  int deadzone = 2;

  // Threshold for considering target heading reached
  double headingThreshold = 1.0;

  // Reset rotation before turning
  Drivetrain.resetRotation();

  // Calculate target heading
  double targetHeading = -targetDegrees;

  // Turn left until the target heading is reached
  while (true) {
    // Calculate current heading
    double currentHeading = -Drivetrain.rotation(degrees);

    // Calculate error
    double error = targetHeading - currentHeading;

    // Ensure error is within the range [-180, 180)
    if (error < -180.0) {
      error += 360.0;
    } else if (error >= 180.0) {
      error -= 360.0;
    }

    // Apply dead zone
    if (fabs(error) < deadzone) {
      error = 0.0;
    }

    // Calculate motor speed based on error
    double motorSpeed = error * kP;

    // Set the motor speeds for left turn
    LeftDriveSmart.setVelocity(motorSpeed, percent);
    RightDriveSmart.setVelocity(-motorSpeed, percent); // Reverse the direction

    // Spin the motors for left turn
    LeftDriveSmart.spin(forward);
    RightDriveSmart.spin(forward);

    // Break the loop if the target heading is reached
    if (fabs(error) < headingThreshold) {
      break;
    }

    // Wait for a short duration
    wait(5, msec);
  }

  // Stop the drivetrain
  Drivetrain.stop();
}

void turnRightDegrees(double targetDegrees) {
  // Proportional gain (adjust as needed)
  double kP = 0.43; // Adjust as needed

  // Dead zone for the controller (adjust as needed)
  int deadzone = 2;

  // Threshold for considering target heading reached
  double headingThreshold = 1.0;

  // Reset rotation before turning
  Drivetrain.resetRotation();

  // Calculate target heading
  double targetHeading = targetDegrees;

  // Turn right until the target heading is reached
  while (true) {
    // Calculate current heading
    double currentHeading = Drivetrain.rotation(degrees);

    // Calculate error
    double error = targetHeading - currentHeading;

    // Ensure error is within the range [-180, 180)
    if (error < -180.0) {
      error += 360.0;
    } else if (error >= 180.0) {
      error -= 360.0;
    }

    // Apply dead zone
    if (fabs(error) < deadzone) {
      error = 0.0;
    }

    // Calculate motor speed based on error
    double motorSpeed = error * kP;

    // Set the motor speeds for right turn
    LeftDriveSmart.setVelocity(-motorSpeed, percent);
    RightDriveSmart.setVelocity(motorSpeed, percent); // Reverse the direction

    // Spin the motors for right turn
    LeftDriveSmart.spin(forward);
    RightDriveSmart.spin(forward);

    // Break the loop if the target heading is reached
    if (fabs(error) < headingThreshold) {
      break;
    }

    // Wait for a short duration
    wait(5, msec);
  }

  // Stop the drivetrain
  Drivetrain.stop();
}