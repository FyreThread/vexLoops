// Constants
const double kProportionalGain = 0.1;
const int kDeadzone = 2;
const double kMinMotorSpeed = 5.0;

// Function for turning by a specified number of degrees (both left and right turns)
void turnDegrees(double targetDegrees, bool isLeftTurn) {
  // Reset heading before each turn
  Drivetrain.setHeading(0.0, degrees);

  // Calculate target heading
  double targetHeading = isLeftTurn ? (Drivetrain.heading() - targetDegrees) : (Drivetrain.heading() + targetDegrees);
  if (targetHeading < 0) {
    targetHeading += 360.0;
  } else if (targetHeading >= 360.0) {
    targetHeading -= 360.0;
  }

  // Turn until target heading is reached
  while (true) {
    // Calculate error
    double error = targetHeading - Drivetrain.heading();
    if (error < -180.0) {
      error += 360.0;
    } else if (error >= 180.0) {
      error -= 360.0;
    }

    // Apply dead zone
    if (fabs(error) < kDeadzone) {
      error = 0.0;
    }
    
    // Calculate motor speed based on error
    double motorSpeed = error * kProportionalGain;
    motorSpeed *= fabs(error / targetDegrees);

    // Ensure minimum motor speed is maintained
    if (fabs(motorSpeed) < kMinMotorSpeed) {
      motorSpeed = copysign(kMinMotorSpeed, motorSpeed);
    }

    // Set motor speeds
    double leftMotorSpeed = isLeftTurn ? motorSpeed : -motorSpeed;
    double rightMotorSpeed = isLeftTurn ? -motorSpeed : motorSpeed;
    LeftDriveSmart.setVelocity(leftMotorSpeed, percent);
    RightDriveSmart.setVelocity(rightMotorSpeed, percent);

    // Spin motors
    LeftDriveSmart.spin(forward);
    RightDriveSmart.spin(forward);

    // Break loop if target heading is reached
    if (fabs(error) < 2.0) {
      Drivetrain.stop();
      Drivetrain.setDriveVelocity(150.0, percent);
      break;
    }
    
    // Wait for short duration
    wait(5, msec);
  }

  // Stop the drivetrain
  Drivetrain.stop();
}