// Constants for PID control
double kP = 0.1;   // Proportional gain
double kI = 0.01;  // Integral gain
double kD = 0.05;  // Derivative gain
const int kDeadzone = 2; // Deadzone for error
const double kMinMotorSpeed = 5.0; // Minimum motor speed to prevent stalling

// Variables for integral control
double integral = 0.0;
const double kMaxIntegral = 100.0; // Maximum allowable integral term
const double kIntegralThreshold = 0.1; // Threshold to prevent small errors from accumulating in the integral term

// Robot dimensions
const double robotWidth = 14.0;  // inches
const double robotLength = 15.0; // inches

// Maximum linear velocity of the robot (assuming the same diameter for all wheels)
const double maxLinearVelocity = (M_PI * 2.75 * 600.0) / (12.0 * 60.0); // inches/second

// Function to turn left smoothly and consistently using PID control
void turnLeft(double targetDegrees) {
    // Reset heading before each turn
    Drivetrain.setHeading(0.0, degrees);

    // Calculate target heading
    double targetHeading = Drivetrain.heading() - targetDegrees;

    // Ensure target heading is within the range [0, 360)
    if (targetHeading < 0) {
        targetHeading += 360.0;
    } else if (targetHeading >= 360.0) {
        targetHeading -= 360.0;
    }

    // Initialize variables for PID control
    double previousError = 0.0;

    // Turn left until the target heading is reached
    while (true) {
        // Calculate error
        double error = targetHeading - Drivetrain.heading();
        
        // Ensure error is within the range [-180, 180)
        if (error < -180.0) {
            error += 360.0;
        } else if (error >= 180.0) {
            error -= 360.0;
        }

        // Apply dead zone
        if (fabs(error) < kDeadzone) {
            error = 0.0;
        }
        
        // Integral control
        integral += error;
        if (fabs(error) < kIntegralThreshold) {
            integral = 0.0; // Prevent small errors from accumulating
        }
        integral = clamp(integral, -kMaxIntegral, kMaxIntegral);

        // Derivative control
        double derivative = error - previousError;

        // Calculate motor speed based on PID terms
        double motorSpeed = kP * error + kI * integral + kD * derivative;

        // Decrease motor speed as error decreases
        motorSpeed *= fabs(error / targetDegrees);

        // Ensure motor speed doesn't fall below minimum threshold
        if (fabs(motorSpeed) < kMinMotorSpeed) {
            motorSpeed = copysign(kMinMotorSpeed, motorSpeed);
        }

        // Calculate motor velocities based on linear velocity and robot dimensions
        double leftMotorVelocity = -maxLinearVelocity;
        double rightMotorVelocity = maxLinearVelocity;

        // Set motor velocities for left turn
        LeftDriveSmart.setVelocity(leftMotorVelocity, percent);
        RightDriveSmart.setVelocity(rightMotorVelocity, percent);

        // Spin motors
        LeftDriveSmart.spin(forward);
        RightDriveSmart.spin(forward);

        // Update previous error
        previousError = error;

        // Break the loop if the target heading is reached
        if (fabs(error) < 2.0) {
            Drivetrain.setDriveVelocity(150.0, percent);
            Drivetrain.stop();
            break;
        }
        
        // Wait for a short duration
        wait(5, msec);
    }

    // Stop the drivetrain after reaching the target heading
    Drivetrain.stop();
}