void driveStraightUntil(double targetDistance) {
    double kP = 0.1; // Proportional gain
    double minMotorSpeed = 20.0; // Minimum motor speed
    double maxMotorSpeed = 50.0; // Maximum motor speed
    double deadZone = 0.5; // Dead zone around the target distance
    
    // Drive forward
    Drivetrain.driveFor(targetDistance, vex::distanceUnits::in, false);
    
    while (true) {
        // Calculate current distance traveled
        double currentDistance = Drivetrain.distance(vex::distanceUnits::in);
        
        // Calculate distance error
        double distanceError = targetDistance - currentDistance;
        
        // Check if within the dead zone
        if (fabs(distanceError) < deadZone) {
            // Stop the robot and break out of the loop
            Drivetrain.stop();
            break;
        }
        
        // Adjust motor speed based on distance error
        double motorSpeed = kP * distanceError;
        if (motorSpeed < minMotorSpeed) {
            motorSpeed = minMotorSpeed;
        } else if (motorSpeed > maxMotorSpeed) {
            motorSpeed = maxMotorSpeed;
        }
        
        // Set motor speeds
        LeftDriveSmart.setVelocity(motorSpeed, vex::velocityUnits::pct);
        RightDriveSmart.setVelocity(motorSpeed, vex::velocityUnits::pct);
        
        // Wait for a short duration before the next iteration
        wait(10, msec);
    }
}