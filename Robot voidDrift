void driveStraightDistance(double targetDistance) {
    double minMotorSpeed = 20.0; // Minimum motor speed
    double maxMotorSpeed = 50.0; // Maximum motor speed
    double deadzone = 0.5; // Dead zone around the target distance
    double initialHeading = DrivetrainInertial.heading(vex::rotationUnits::deg); // Initial heading
    
    // Drive forward
    Drivetrain.driveFor(targetDistance, vex::distanceUnits::in, false);
    
    while (true) {
        // Calculate current heading
        double currentHeading = DrivetrainInertial.heading(vex::rotationUnits::deg);
        
        // Calculate change in heading
        double headingChange = currentHeading - initialHeading;
        
        // Estimate distance traveled based on heading change
        double distanceTraveled = (headingChange / 360.0) * (3.14 * wheelDiameter); // Assuming wheelDiameter is defined
        
        // Calculate remaining distance
        double remainingDistance = targetDistance - distanceTraveled;
        
        // Check if within the dead zone
        if (fabs(remainingDistance) < deadzone) {
            // Stop the robot and break out of the loop
            Drivetrain.stop();
            break;
        }
        
        // Calculate motor speed based on remaining distance
        double motorSpeed = maxMotorSpeed * (remainingDistance / targetDistance);
        
        // Ensure motor speed stays within bounds
        if (motorSpeed < minMotorSpeed) {
            motorSpeed = minMotorSpeed;
        } else if (motorSpeed > maxMotorSpeed) {
            motorSpeed = maxMotorSpeed;
        }
        
        // Set motor speeds for driving straight
        LeftDriveSmart.setVelocity(motorSpeed, vex::velocityUnits::pct);
        RightDriveSmart.setVelocity(motorSpeed, vex::velocityUnits::pct);
        
        // Wait for a short duration before the next iteration
        wait(10, msec);
    }
    
    // After breaking out of the loop, stop the motors and release control of the drivetrain
    Drivetrain.stop();
}